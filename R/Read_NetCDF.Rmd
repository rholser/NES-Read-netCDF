---
title: "Access Eseal netCDF Data"
author: "R. Holser and S. Abdel-Raheem"
Date Created: July 19, 2023
output:
  html_document:
    code_folding: hide
    df_print: paged
  word_document: default
  pdf_document: default
---

```{r Settings, echo=FALSE}
knitr::opts_chunk$set(warning = FALSE, fig.width = 9, message=FALSE, error=FALSE)
```

Updated at `r Sys.time()`

```{r Libraries, echo=FALSE}
require(ncdf4)
require(ggspatial)
require(sf)
require(plotly) #tool to generate interactive plots for exploring data
require(lubridate)
require(tidyverse)
require(here)
```

# Opening File and Metadata

NetCDF files must be accessed by first identifying and opening the file using `ncid <- nc_open(filename)`. This ID is used to access information within the file and the file remains "open" until the command `nc_close(filename)` is used to close the connection.

```{r nc open, class.source = 'fold-show'}
# set path and filename for a [processed] data file (2017001_TrackTDR_Processed.nc) as an example
ncpath <- here("Data")
ncname_processed <- "2017001_TrackTDR_Processed"  

ncfname_processed <- paste(ncpath, "/", ncname_processed, ".nc", sep = "")

#open netCDF files
ncid_P <- nc_open(ncfname_processed)
```

Metadata are available throughout the file as attributes. The command `ncatt_get(FileID, VariableName)` will retrieve attribute information for each variable within the file. Use `0` for the `VariableName` to read Global Attributes.

```{r nc file attributes, class.source = 'fold-show'}
#pull in global attributes, for processed "_P" data
Info_global_P <- ncatt_get(ncid_P, 0)

# Convert the named list to a tibble
nc_attributes_P <- tibble(
  Attribute = names(Info_global_P),
  Type = sapply(Info_global_P, class),
  Value = unlist(Info_global_P, use.names = FALSE)
  )
```

To access the attributes of variables within groups, you include the group and variable name in quotes `" "`, separated by a forward slash `/`: `"GROUP/VAR"`. You can access the `nc_attributes` tibble previously generated to more readily access the groups and variables in a file or call `Info_global_P` in the console.

```{r track attributes, class.source = 'fold-show'}
#Attributes for TRACK/DATE, 
Info_track_P <- ncatt_get(ncid_P,"TRACK/DATE")
print(Info_track_P)
```

# Reading in Data

Each variable must be read individually using the function `ncvar_get(FileID, VariableName)`. Group and subgroup structure is indicated within the variable name: `GROUP/VAR` or `GROUP/SUBGROUP/VAR`.

## Track Data

Tracking data are all kept in the group `TRACK`. Processed files have compiled and interpolated tracking data which are represented at equal temporal distributions. Raw curated track data are not processed and so can over-represent presence data. Below is a demonstration of how to plot a single track record.

First, create a pared down data frame from the `TRACK` data group. Use the `ncvar_get()` function to call on the variable of interest from the group using the notation introduced prior, i.e. `ncvar_get(ncfile, "GROUP/VAR")`. Select the `"TRACK/LAT"`, `"TRACK/LON"`, and `"TRACK/DATE"` variables and combine them in a data frame/tibble.

```{r plot tracking data, class.source = 'fold-show'}

#Pull relevant data from processed track record
trackLat <- ncvar_get(ncid_P, "TRACK/LAT")
trackLon <- ncvar_get(ncid_P, "TRACK/LON")
trackDate <- ncvar_get(ncid_P, "TRACK/DATE") %>% 
  as.POSIXct()

#Create a track dataframe for plotting
track <- tibble(
  #Round lat-lon data to 3rd decimal place
  trackLat = as.numeric(round(trackLat, 3)),
  trackLon = as.numeric(round(trackLon, 3)),
  trackDateTime = trackDate) %>% 
  arrange(trackDate) %>% #Arrange in ascending date-time order
  #Convert Date into Julian day format for ease of color labelling
  mutate(
    JDay = yday(trackDate), #extract the Julian Day from the date-time
    DayFraction = (hour(trackDate) + #extract the HMS from date-time 
                     minute(trackDate)/ 60 + #calculate fraction of the 24-hour day
                     second(trackDate) / 3600) / 24,
    JDateTime = JDay + DayFraction #add Julian day with the fraction to get a
                                  #calculate the Julian Date-Time
  ) 

head(track)
```

### Plot the tracking data

```{r color scale set up}
#Next, set up the viridis color scale to work with the Plotly interactive plotting environment
library(viridis)

# Function to convert viridis to Plotly format
viridis_to_plotly <- function(n, option = "D") {
  colors <- viridis(n, option = option)
  return(lapply(seq_along(colors), function(i) list((i - 1) / (n - 1), colors[i])))
}

# Convert viridis colors to Plotly format
colorscale <- viridis_to_plotly(256, option = "D")
```

Use [plotly open source graphing library](https://plotly.com/r/) to generate dynamic and interactive map of tracking data. Please note, an internet connection is needed to view the final output.

```{r single record track map}
#Plot the tracking data using the track dataframe 
track_map <- plot_ly(data = track, 
                     type = 'scattergeo', 
                     mode = 'markers',
                     lat = ~trackLat, 
                     lon = ~trackLon, 
                     #Formatting for the hover labels
                     #Hover label format = 
                     #  Lat: YY.YYY
                     #  Lon: -XXX.XXX
                     #  Date-Time: YYYY-MM-DD HH:MM:SS
                     text = ~paste(
                       "Lat: ", trackLat,"°",
                       "<br>Lon: ", trackLon,"°",
                       "<br>Date-Time: ", trackDateTime), 
                     hoverinfo = 'text',
                     #Formatting for data points and how they are colored
                     marker = list(
                       #Use the Julian Date-Time object to set the sequence
                       color = ~JDateTime,
                       colorscale = colorscale,  # Use the converted viridis color scale
                       colorbar = list(
                         # Specify tick values and labels in the color bar
                         tickvals = c(min(track$JDateTime), max(track$JDateTime)),  
                         ticktext = c("trip start", "trip end"),  # Specify tick labels
                         len = 1  # Ensure color bar uses the full height
                         ),
                       size = 5)) %>%
  layout(
    title = list(
      #Title Format = Deployment ID Deployment Trip Processed Track Data
      text = paste0(Info_global_P$Deployment_ID, " ", 
                    Info_global_P$Deployment_Trip, " Processed Track Data"),
      y = 0.85,  # Adjust title position vertically (0-1 range)
      yanchor = "top"  # Optional: Anchor title position to the top
    ),
    geo = list(
      projection = list(type = 'natural earth'),
      showland = TRUE,
      resolution = 50, # Country level resolution for map
      landcolor = "gray",
      #Set the initial view/extent of the map output
      lonaxis = list(
        range = c(-230, -60)  # Longitude range from east coasts of US to Japan
      ),
      lataxis = list(
        range = c(15, 70) # Latitude range to cover relevant area
      )
    ),
    #Set the whitespace margins
    margin = list(
      l = 10,  # Left margin (adjust as needed)
      r = 10 # Right margin (adjust as needed)
    ))

track_map
```

## Diving Data

Diving data are kept in the groups `TDR1`, `TDR2`, and `TDR3`, with `TDR1` as the primary dive record. Similar to the `TRACK` map, to plot dive data, first create a pared down data frame of the variables of interest using the `ncvar_get()` function and reference the `TDR1` group to extract and compile `LAT`, `LON`, `DATE`, and `DEPTH` data.

```{r plot TDR1 dive record}
#Pull relevant data from processed dive record
#Note pull lat-long data to later make a 3D plot of dive record

diveLat_P <-ncvar_get(ncid_P,"TDR1/LAT")
diveLon_P <-ncvar_get(ncid_P,"TDR1/LON")
diveDate_P <-ncvar_get(ncid_P,"TDR1/DATE") %>% 
  as.POSIXct(format = "%d-%b-%Y %H:%M:%S", tz = "UTC")
Depth_P <-ncvar_get(ncid_P,"TDR1/MAXDEPTH")

#create a dataframe for plotting
dive_P<- tibble(
  #Round lat-lon data to 3rd decimal place
  diveLat = as.numeric(round(diveLat_P, 3)),
  diveLon = as.numeric(round(diveLon_P, 3)),
  diveDateTime = diveDate_P, 
  diveDepth = Depth_P) %>% 
  arrange(diveDateTime) %>% #Arrange in ascending date-time order
  mutate(
    JDay = yday(diveDateTime), #extract the Julian Day from the date-time
    DayFraction = (hour(diveDateTime) + #extract the HMS from date-time to 
                     minute(diveDateTime)/ 60 + #calculate the fraction 
                     second(diveDateTime) / 3600) / 24, #of the 24-hour day
    JDateTime = JDay + DayFraction #add Julian day with the fraction to get a
                                  #calculate the Julian Date-Time
  )

head(dive_P)
```

### Plot the diving data

Use [plotly open source graphing library](https://plotly.com/r/) to generate dynamic and interactive plots of dive data. Please note, an internet connection is needed to view the final output.

```{r generate a 2-D and 3-D dive plot for a single record}
#Plot processed dive record against time (2-D)
TDR1_P <- plot_ly(data = dive_P, x = ~diveDateTime, y = ~diveDepth, 
                       type = 'scatter', 
                       mode = 'markers',
                     #setting so that hover labels show full date-time data
                     text = ~paste("Date-Time: ", diveDateTime, 
                                   "<br>Depth: ", diveDepth, "m"), 
                     hoverinfo = 'text') %>%
  layout(
    #Title of the plot will dynamically generate based on nc file info
    #Format = "Deployment ID Deployment Trip Processed Dive Data"
    title = paste0(Info_global_P$Deployment_ID, " ", 
                   Info_global_P$Deployment_Trip, " Processed Dive Data"),
    yaxis = list(title = "Depth (m)",
                 autorange = "reversed"), #more intuitive for interpreting depth
    xaxis = list(title = "Date",
                 tickformat = "%d-%b"), #more readable than full date-time format
    hoverlabel = list(
      bgcolor = "white",  # Optional: Set background color of hover label
      font = list(family = "Arial", size = 12))  # Optional: Customize font
  )

TDR1_P

#Different way to visualize the same data but using bars instead of points
TDR1_Pbar <- plot_ly(data = dive_P, x = ~diveDateTime, y = ~diveDepth, 
                       type = 'bar', 
                     #setting so that hover labels show full date-time data
                     text = ~paste("Date-Time: ", diveDateTime, 
                                   "<br>Depth: ", diveDepth, "m"), 
                     hoverinfo = 'text') %>%
  layout(
    #Title of the plot will dynamically generate based on nc file info
    #Format = "Deployment ID Deployment Trip Processed Dive Data"
    title = paste0(Info_global_P$Deployment_ID, " ", 
                   Info_global_P$Deployment_Trip, " Processed Dive Data"),
    yaxis = list(title = "Depth (m)",
                 autorange = "reversed"), #more intuitive for interpreting depth
    xaxis = list(title = "Date",
                 tickformat = "%d-%b"), #more readable than full date-time format
    hoverlabel = list(
      bgcolor = "white",  # Optional: Set background color of hover label
      font = list(family = "Arial", size = 12))  # Optional: Customize font
  )

TDR1_Pbar

#Plot processed dive record on a cartesian (lat-long) grid
#Note this is readily done only for processed data and NOT for raw curated data
LatLong_TDR_P <- plot_ly(data = dive_P, 
                         x = ~diveLon, y = ~diveLat, z = ~diveDepth, 
                         type = 'scatter3d', mode = 'markers',
                         marker = list(
                           #Use the Julian Date-Time object to set the sequence
                           color = ~JDateTime,
                           # Use the converted viridis color scale
                           colorscale = colorscale,
                           colorbar = list(
                             # Specify tick values and labels in the color bar
                             tickvals = c(min(dive_P$JDateTime), max(dive_P$JDateTime)),
                             ticktext = c("trip start", "trip end"),  # Specify tick labels
                             len = 1  # Ensure color bar uses the full height
                             ),
                           size = 3),
                         #setting so that hover labels show full date-time data
                         text = ~paste("Lat: ", diveLat,"°",
                                       "<br>Lon: ", diveLon,"°",
                                       "<br>Depth: ", diveDepth, "m"),
                         hoverinfo = 'text') %>%
  layout(
    scene = list(
      xaxis = list(title = 'Longitude'),
      yaxis = list(title = 'Latitude'),
      zaxis = list(title = 'Depth', autorange = "reversed")
    ),
    #Title of the plot will dynamically generate based on nc file info
    #Format = "Deployment ID Deployment Trip Processed 3D Dive Data"
    title = paste0(Info_global_P$Deployment_ID, " ", 
                   Info_global_P$Deployment_Trip, " Processed 3D Dive Data")
  )

LatLong_TDR_P
```

## Load and Plot Multiple Records

### Read in Multiple Track and Dive Records

You can read in multiple nc files and plot their track and dive records to compare differences and similarities among records. Below is an example of a for-loop that loads and reads in 6 netCDF files and extracts relevant data for plotting. 

```{r Load Multiple Records}

# List all files with the pattern "*Processed.nc"
files <- list.files(here("Data"), pattern = "*Processed.nc", full.names = TRUE)
print(files)

# Initialize empty tibbles for Tracks and Dives with the specified column types
Tracks <- tibble(
  TOPPID = double(),
  SealID = character(),
  QCFlag = double(),
  Date = character(),  # Start as character for easier binding
  Lat = double(),
  Lon = double()
)

Dives <- tibble(
  TOPPID = double(),
  SealID = character(),
  Date = character(),  # Start as character for easier binding
  Depth = double(),
  Duration = double(),
  Lat = double(),
  Lon = double(),
  QCFlag = double()
)

# Loop through each file and process it
for (i in 1:length(files)) {
  message("Processing file: ", i)
  
  # Open the NetCDF file
  nc <- nc_open(files[i])
  
  # Extract metadata
  metadata <- list()
  attrs <- ncatt_get(nc, 0)
  for (attr in names(attrs)) {
    metadata[[make.names(attr)]] <- attrs[[attr]]
  }

  # Extract sizes of track and dive data
  Tsize <- nc$dim$TRACK$len
  Dsize <- nc$dim$`TDR1/NumDives`$len
  
  message("Tsize: ", Tsize, " QC Flags: ", metadata$Data_Track_QCFlag)
  message("Dsize: ", Dsize, " QC Flags: ", metadata$Data_TDR1_QCFlag)
  
  # Read and extract track data if QC flag is appropriate
  if (metadata$Data_Track_QCFlag > 3) {
     message("FYI Track data quality flag was above 3; data are not extracted.")
  } else {
    track_data <- tibble(
#Repeat the QC Flag, Deployment and Seal IDs for the length (Tsize) of the track file
      TOPPID = rep(metadata$Deployment_ID, Tsize),
      SealID = rep(metadata$Animal_ID, Tsize),
      QCFlag = rep(metadata$Data_Track_QCFlag, Tsize),
      Date = ncvar_get(nc, "TRACK/DATE"),
      Lat = ncvar_get(nc, "TRACK/LAT"),
      Lon = ncvar_get(nc, "TRACK/LON")
    )
    Tracks <- bind_rows(Tracks, track_data)
  }

  # Read and extract dive data if QC flag is appropriate
  if (metadata$Data_TDR1_QCFlag > 3) {
     message("FYI Dive data quality flag was above 3; data are not extracted.")
  } else {
    dive_data <- tibble(
#Repeat the QC Flag, Deployment and Seal IDs for the length (Dsize) of the dive file
      TOPPID = rep(metadata$Deployment_ID, Dsize),
      SealID = rep(metadata$Animal_ID, Dsize),
      QCFlag = rep(metadata$Data_TDR1_QCFlag, Dsize),
      Date = ncvar_get(nc, "TDR1/DATE"),
      Lat = ncvar_get(nc, "TDR1/LAT"),
      Lon = ncvar_get(nc, "TDR1/LON"),
      Depth = ncvar_get(nc, "TDR1/MAXDEPTH"),
      Duration = ncvar_get(nc, "TDR1/DURATION")
    )
    Dives <- bind_rows(Dives, dive_data)
  }
  
  # Close the NetCDF file
  nc_close(nc)
}

# Convert Date columns to datetime objects
Tracks <- Tracks %>%
  mutate(Date = ymd_hms(Date))

Dives <- Dives %>%
  mutate(Date = dmy_hms(Date))

# Remove rows with missing TOPPID
Tracks <- Tracks %>%
  filter(!is.na(TOPPID))

Dives <- Dives %>%
  filter(!is.na(TOPPID))

print("Processing completed.")
```

### Plot Multiple Tracks

Use [plotly open source graphing library](https://plotly.com/r/) to generate dynamic and interactive map of tracking data. Please note, an internet connection is needed to view the final output.

```{r plot multiple tracks}
#Plot the tracking data using the Tracks aggregated dataframe 
Tracks_map <- plot_ly(data = Tracks, 
                     type = 'scattergeo', 
                     mode = 'markers',
                     split = ~SealID, 
                     lat = ~Lat, 
                     lon = ~Lon, 
                     #Formatting for the hover labels
                     #Hover label format = 
                     #  Lat: YY.YYY
                     #  Lon: -XXX.XXX
                     #  Date-Time: YYYY-MM-DD HH:MM:SS
                     text = ~paste(
                       "Seal ID: ", SealID, 
                       "<br>Deployment ID: ", TOPPID,
                       "<br>Lat: ", sprintf("%.3f", Lat), "°",
                       "<br>Lon: ", sprintf("%.3f", Lon), "°",
                       "<br>Date-Time: ", Date), 
                     hoverinfo = 'text',
                     #Formatting for data points and how they are colored
                     marker = list(
                       colorscale = ~SealID,
                       size = 5)) %>%
  layout(
    title = list(
      #Title Format = Deployment ID Deployment Trip Processed Track Data
      text = paste0("Aggregated and Processed Track Data"),
      y = 0.85,  # Adjust title position vertically (0-1 range)
      yanchor = "top"  # Optional: Anchor title position to the top
    ),
    geo = list(
      projection = list(type = 'natural earth'),
      showland = TRUE,
      resolution = 50, # Country level resolution for map
      landcolor = "gray",
      #Set the initial view/extent of the map output
      lonaxis = list(
        range = c(-230, -60)  # Longitude range from east coasts of US to Japan
      ),
      lataxis = list(
        range = c(15, 70) # Latitude range to cover relevant area
      )
    ),
    #Set the whitespace margins
    margin = list(
      l = 10,  # Left margin (adjust as needed)
      r = 10 # Right margin (adjust as needed)
    ), 
    legend = list(
      title = list(text = 'Seal ID'),  # Add legend title
      y = 0.5,  # Vertically center the legend
      yanchor = 'middle'  # Anchor the legend at its middle
    ))

Tracks_map
```

### Plot Multiple Dive Records

Use [plotly open source graphing library](https://plotly.com/r/) to generate dynamic and interactive 3-D plot of tracking data. Please note, an internet connection is needed to view the final output.

```{r plot multiple dive records}
#Plot processed dive records on a cartesian (lat-long) grid
Dives_plot <- plot_ly(data = Dives, 
                      x = ~Lon, 
                      y = ~Lat, 
                      z = ~Depth,
                      split = ~SealID,
                      type = 'scatter3d', 
                      mode = 'markers',
                         marker = list(
                           colorscale = ~SealID,
                           size = 3),
                         #setting so that hover labels show full date-time data
                         text = ~paste(
                           "Seal ID: ", SealID,
                           "<br>Deployment ID: ", TOPPID,
                           "<br>Depth: ", Depth, "m",
                           "<br>Duration: ", Duration, "min",
                           "<br>Lat: ", sprintf("%.3f", Lat), "°",
                           "<br>Lon: ", sprintf("%.3f", Lon), "°",
                           "<br>Date-Time: ", Date),
                         hoverinfo = 'text') %>%
  layout(
    scene = list(
      xaxis = list(title = 'Longitude'),
      yaxis = list(title = 'Latitude'),
      zaxis = list(title = 'Depth', autorange = "reversed")
    ),
    #Title of the plot will dynamically generate based on nc file info
    #Format = "Deployment ID Deployment Trip Processed 3D Dive Data"
    title = "Aggregated and Processed 3D Dive Data",
    legend = list(
      title = list(text = 'Seal ID'),  # Add legend title
      y = 0.5,  # Vertically center the legend
      yanchor = 'middle'  # Anchor the legend at its middle
  ))

Dives_plot
```

## Load and plot ZOC'd full resolution (Raw Curated) TDR data

Full resolution TDR data files are quite large and are stored on Dryad open data publishing platform doi: <http://doi.org/10.7291/D18D7W>.

To load and read the data follow the steps previously demonstrated. Because of the size of these files, using the plotly interactive plotting library is hugely processing intensive and may cause R to crash when attempting to plot the raw curated data. For the larger raw curated data files, plotting is demonstrated using ggplot.

```{r raw data, echo=FALSE}
# set path and filename for a Raw Curated data file (2017001_TrackTDR_RawCurated.nc) as an example
#note that because Raw Curated files are stored on Dryad, these files will have a different path than the processed files shared and stored on GitHub. 

ncpath_R <- here("/Users/salmaabdel-raheem/Documents/GitHub/PhD/NCFileExploration")

ncname_R <- "2017001_TrackTDR_RawCurated"
ncfname_R <- paste(ncpath_R, "/", ncname_R, ".nc", sep = "")

#open netCDF files
ncid_R <- nc_open(ncfname_R)

#Pull relevant data from raw curated dive record
diveDate_R <-ncvar_get(ncid_R,"CLEAN_ZOC_TDR1/DATE")

#pull in global attributes, for raw "_R" data
Info_global_R <- ncatt_get(ncid_R, 0)

#Figure out the origin of the date-time object
Origin_CleanZOCTDR<-ncatt_get(ncid_R,"CLEAN_ZOC_TDR1/DATE")
print(Origin_CleanZOCTDR)

#Convert the date-time object from a character to a POSIXct
diveDate_R <- as.POSIXct(((diveDate_R - 719529)*86400),
                          origin = "1970-01-01", tz = "UTC")

Depth_R <- ncvar_get(ncid_R, "CLEAN_ZOC_TDR1/DEPTH")

#create a dataframe for plotting
dive_R <- tibble(diveDate_R, Depth_R)

#Plot raw curated dive record against time.

TDR1_R <- ggplot(dive_R, aes(x = diveDate_R, y = Depth_R)) +
  geom_line(color = "#38618A") +
  labs(
    title = paste0(Info_global_R$Deployment_ID, " ",
                   Info_global_R$Deployment_Trip, " Raw Curated Dive Data"),
    x = "Date",
    y = "Depth (m)"
  ) +
  scale_y_reverse() +
  scale_x_datetime(date_breaks = "2 weeks", date_labels = "%d-%b") +
  theme_minimal() +
  theme(
    panel.background = element_rect(color = "lightgray", size = 1)
  )

TDR1_R

```

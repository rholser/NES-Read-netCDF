#     title = paste0(Info_global_R$Deployment_ID, " ",
#                    Info_global_R$Deployment_Trip, " Raw Curated Dive Data"),
#     yaxis = list(title = "Depth (m)",
#                  autorange = "reversed"), #more intuitive for interpreting depth
#     xaxis = list(title = "Date",
#                  tickformat = "%d-%b"), #more readable than full date-time format
#     hoverlabel = list(
#       bgcolor = "white",  # Optional: Set background color of hover label
#       font = list(family = "Arial", size = 12))  # Optional: Customize font
#   )
#
# TDR1_Ddat_R
#Pull relevant data from processed dive record
#Note pull lat-long data to later make a 3D plot of dive record
diveLat_P <-ncvar_get(ncid_P,"TDR1/LAT")
diveLon_P <-ncvar_get(ncid_P,"TDR1/LON")
diveDate_P <-ncvar_get(ncid_P,"TDR1/DATE")
diveDate_P <- as.POSIXct(diveDate_P, format = "%d-%b-%Y %H:%M:%S", tz = "UTC")
Depth_P <-ncvar_get(ncid_P,"TDR1/MAXDEPTH")
#create a dataframe for plotting
dive_P<-data.frame(diveLat_P,
diveLon_P,
diveDate_P,
Depth_P) %>%
mutate(
JDay = yday(diveDate_P), #extract the Julian Day from the date-time
DayFraction = (hour(diveDate_P) + #extract the HMS from date-time to
minute(diveDate_P)/ 60 + #calculate the fraction
second(diveDate_P) / 3600) / 24, #of the 24-hour day
JDateTime = JDay + DayFraction #add Julian day with the fraction to get a
#calculate the Julian Date-Time
)
#Plot processed dive record against time
TDR1_Ddat_P <- plot_ly(data = dive_P, x = ~diveDate_P, y = ~Depth_P,
type = 'scatter',
mode = 'markers',
#setting so that hover labels show full date-time data
text = ~paste("Date-Time: ", diveDate_P,
"<br>Depth: ", Depth_P),
hoverinfo = 'text') %>%
layout(
#Title of the plot will dynamically generate based on nc file info
#Format = "Deployment ID Deployment Trip Processed Dive Data"
title = paste0(Info_global_P$Deployment_ID, " ",
Info_global_P$Deployment_Trip, " Processed Dive Data"),
yaxis = list(title = "Depth (m)",
autorange = "reversed"), #more intuitive for interpreting depth
xaxis = list(title = "Date",
tickformat = "%d-%b"), #more readable than full date-time format
hoverlabel = list(
bgcolor = "white",  # Optional: Set background color of hover label
font = list(family = "Arial", size = 12))  # Optional: Customize font
)
TDR1_Ddat_P
#Different way to visualize the same data but using bars instead of points
TDR1_Ddat_Pbar <- plot_ly(data = dive_P, x = ~diveDate_P, y = ~Depth_P,
type = 'bar',
#setting so that hover labels show full date-time data
text = ~paste("Date-Time: ", diveDate_P,
"<br>Depth: ", Depth_P),
hoverinfo = 'text') %>%
layout(
#Title of the plot will dynamically generate based on nc file info
#Format = "Deployment ID Deployment Trip Processed Dive Data"
title = paste0(Info_global_P$Deployment_ID, " ",
Info_global_P$Deployment_Trip, " Processed Dive Data"),
yaxis = list(title = "Depth (m)",
autorange = "reversed"), #more intuitive for interpreting depth
xaxis = list(title = "Date",
tickformat = "%d-%b"), #more readable than full date-time format
hoverlabel = list(
bgcolor = "white",  # Optional: Set background color of hover label
font = list(family = "Arial", size = 12))  # Optional: Customize font
)
TDR1_Ddat_Pbar
#Plot processed dive record on a cartesian (lat-long) grid
#Note this is readily done only for processed data and NOT for raw curated data
LatLong_TDR_P <- plot_ly(data = dive_P,
x = ~diveLon_P, y = ~diveLat_P, z = ~Depth_P,
type = 'scatter3d', mode = 'markers',
marker = list(
#Use the Julian Date-Time object to set the sequence
color = ~JDateTime,
# Use the converted viridis color scale
colorscale = colorscale,
colorbar = list(
# Specify tick values and labels in the color bar
tickvals = c(min(dive_P$JDateTime), max(dive_P$JDateTime)),
ticktext = c("trip start", "trip end"),  # Specify tick labels
len = 1  # Ensure color bar uses the full height
),
size = 3)) %>%
layout(
scene = list(
xaxis = list(title = 'Longitude'),
yaxis = list(title = 'Latitude'),
zaxis = list(title = 'Depth', autorange = "reversed")
),
#Title of the plot will dynamically generate based on nc file info
#Format = "Deployment ID Deployment Trip Processed 3D Dive Data"
title = paste0(Info_global_P$Deployment_ID, " ",
Info_global_P$Deployment_Trip, " Processed 3D Dive Data")
)
LatLong_TDR_P
# set path and filenames for processed and raw curated data
ncpath <- "/Users/salmaabdel-raheem/Documents/GitHub/PhD/NCFileExploration"
ncname_raw <- "2017001_TrackTDR_RawCurated"
ncfname_raw <- paste(ncpath, ncname_raw, ".nc", sep="")
ncname_processed <- "2017001_TrackTDR_Processed"
ncfname_processed <- paste(ncpath, ncname_processed, ".nc", sep="")
#open netCDF files
ncid_R<-nc_open(ncfname_raw)
ncname_raw <- "2017001_TrackTDR_RawCurated"
ncfname_raw <- paste(ncpath, ncname_raw, ".nc", sep="")
ncname_processed <- "2017001_TrackTDR_Processed"
ncfname_processed <- paste(ncpath, ncname_processed, ".nc", sep="")
#open netCDF files
ncid_R<-nc_open(ncfname_raw)
ncid_P<-nc_open(ncfname_processed)
# set path and filenames for processed and raw curated data
ncpath <- "/Users/salmaabdel-raheem/Documents/GitHub/PhD/NCFileExploration/"
ncname_raw <- "2017001_TrackTDR_RawCurated"
ncfname_raw <- paste(ncpath, ncname_raw, ".nc", sep="")
ncname_processed <- "2017001_TrackTDR_Processed"
ncfname_processed <- paste(ncpath, ncname_processed, ".nc", sep="")
#open netCDF files
ncid_R<-nc_open(ncfname_raw)
ncid_P<-nc_open(ncfname_processed)
#pull in global attributes, for raw curated "_R" data
#Curated Raw data are available if the user so chooses to process the data differently
#However,
Info_global_R<-ncatt_get(ncid_R,"")
as.data.frame(Info_global_R)
View(Info_global_R)
#pull in global attributes, for processed "_P" data
Info_global_P<-ncatt_get(ncid_P,"")
as.data.frame(Info_global_P)
View(Info_global_P)
# List of NetCDF files
files <- list.files(pattern = "*Processed.nc")
# Initialize empty tibbles for Tracks and Dives with the specified column types
Tracks <- tibble(
TOPPID = double(),
SealID = character(),
Date = character(),
Lat = double(),
Lon = double(),
QCFlag = double()
)
require(tidyverse)
# List of NetCDF files
files <- list.files(pattern = "*Processed.nc")
# Initialize empty tibbles for Tracks and Dives with the specified column types
Tracks <- tibble(
TOPPID = double(),
SealID = character(),
Date = character(),
Lat = double(),
Lon = double(),
QCFlag = double()
)
Dives <- tibble(
TOPPID = double(),
SealID = character(),
Date = character(),
Depth = double(),
Duration = double(),
Lat = double(),
Lon = double(),
QCFlag = double()
)
# Function to read and process a NetCDF file
process_nc_file <- function(file) {
nc <- nc_open(file)
metadata <- list()
# Extract metadata
attrs <- ncatt_get(nc, 0)
for (attr in names(attrs)) {
metadata[[make.names(attr)]] <- attrs[[attr]]
}
# Extract sizes of track and dive data
Tsize <- nc_dim(nc, "TRACK")$len
Dsize <- nc_dim(nc, "TDR1")$len
# Initialize empty lists to store extracted data
track_data <- list()
dive_data <- list()
if (metadata$Data_Track_QCFlag <= 3) {
track_data <- tibble(
TOPPID = rep(metadata$Deployment_ID, Tsize),
SealID = rep(metadata$Animal_ID, Tsize),
QCFlag = rep(metadata$Data_Track_QCFlag, Tsize),
Date = ncvar_get(nc, "/TRACK/DATE"),
Lat = ncvar_get(nc, "/TRACK/LAT"),
Lon = ncvar_get(nc, "/TRACK/LON")
)
}
if (metadata$Data_TDR1_QCFlag <= 3) {
dive_data <- tibble(
TOPPID = rep(metadata$Deployment_ID, Dsize),
SealID = rep(metadata$Animal_ID, Dsize),
QCFlag = rep(metadata$Data_TDR1_QCFlag, Dsize),
Date = ncvar_get(nc, "/TDR1/DATE"),
Lat = ncvar_get(nc, "/TDR1/LAT"),
Lon = ncvar_get(nc, "/TDR1/LON"),
Depth = ncvar_get(nc, "/TDR1/MAXDEPTH"),
Duration = ncvar_get(nc, "/TDR1/DURATION")
)
}
nc_close(nc)
# Convert date strings to datetime objects
if (nrow(track_data) > 0) {
track_data <- track_data %>%
mutate(Date = ymd_hms(Date))
}
if (nrow(dive_data) > 0) {
dive_data <- dive_data %>%
mutate(Date = ymd_hms(Date))
}
list(Tracks = track_data, Dives = dive_data)
}
# Loop through each file and process it
for (file in files) {
data <- process_nc_file(file)
if (nrow(data$Tracks) > 0) {
Tracks <- bind_rows(Tracks, data$Tracks)
}
if (nrow(data$Dives) > 0) {
Dives <- bind_rows(Dives, data$Dives)
}
}
# Print the resulting data frames
print(Tracks)
print(Dives)
View(track_map)
View(Tracks)
View(track)
# List of NetCDF files
files <- list.files(pattern = "*Processed.nc")
getwd()
setwd("/Users/salmaabdel-raheem/Documents/GitHub/PhD/NCFileExploration/")
# List of NetCDF files
files <- list.files(pattern = "*Processed.nc")
# Initialize empty tibbles for Tracks and Dives with the specified column types
Tracks <- tibble(
TOPPID = double(),
SealID = character(),
Date = character(),
Lat = double(),
Lon = double(),
QCFlag = double()
)
Dives <- tibble(
TOPPID = double(),
SealID = character(),
Date = character(),
Depth = double(),
Duration = double(),
Lat = double(),
Lon = double(),
QCFlag = double()
)
# Function to read and process a NetCDF file
process_nc_file <- function(file) {
nc <- nc_open(file)
metadata <- list()
# Extract metadata
attrs <- ncatt_get(nc, 0)
for (attr in names(attrs)) {
metadata[[make.names(attr)]] <- attrs[[attr]]
}
# Extract sizes of track and dive data
Tsize <- nc_dim(nc, "TRACK")$len
Dsize <- nc_dim(nc, "TDR1")$len
# Initialize empty lists to store extracted data
track_data <- list()
dive_data <- list()
if (metadata$Data_Track_QCFlag <= 3) {
track_data <- tibble(
TOPPID = rep(metadata$Deployment_ID, Tsize),
SealID = rep(metadata$Animal_ID, Tsize),
QCFlag = rep(metadata$Data_Track_QCFlag, Tsize),
Date = ncvar_get(nc, "/TRACK/DATE"),
Lat = ncvar_get(nc, "/TRACK/LAT"),
Lon = ncvar_get(nc, "/TRACK/LON")
)
}
if (metadata$Data_TDR1_QCFlag <= 3) {
dive_data <- tibble(
TOPPID = rep(metadata$Deployment_ID, Dsize),
SealID = rep(metadata$Animal_ID, Dsize),
QCFlag = rep(metadata$Data_TDR1_QCFlag, Dsize),
Date = ncvar_get(nc, "/TDR1/DATE"),
Lat = ncvar_get(nc, "/TDR1/LAT"),
Lon = ncvar_get(nc, "/TDR1/LON"),
Depth = ncvar_get(nc, "/TDR1/MAXDEPTH"),
Duration = ncvar_get(nc, "/TDR1/DURATION")
)
}
nc_close(nc)
# Convert date strings to datetime objects
if (nrow(track_data) > 0) {
track_data <- track_data %>%
mutate(Date = ymd_hms(Date))
}
if (nrow(dive_data) > 0) {
dive_data <- dive_data %>%
mutate(Date = ymd_hms(Date))
}
list(Tracks = track_data, Dives = dive_data)
}
# Loop through each file and process it
for (file in files) {
data <- process_nc_file(file)
if (nrow(data$Tracks) > 0) {
Tracks <- bind_rows(Tracks, data$Tracks)
}
if (nrow(data$Dives) > 0) {
Dives <- bind_rows(Dives, data$Dives)
}
}
# Print the resulting data frames
print(Tracks)
print(Dives)
getwd()
setwd("/Users/salmaabdel-raheem/Documents/GitHub/PhD/NCFileExploration")
# List of NetCDF files
files <- list.files(pattern = "*Processed.nc")
# List of NetCDF files
files <- list.files(pattern = "*_Processed.nc")
# Check if files are found
if (length(files) == 0) {
stop("No files found in the directory with the pattern *Processed.nc")
}
list.files("/Users/salmaabdel-raheem/Documents/GitHub/PhD/NCFileExploration")
list.files("/Users/salmaabdel-raheem/Documents/GitHub/PhD/NCFileExploration", pattern = "*Processed.nc")
# List of NetCDF files
files <- list.files(pattern = "*Processed.nc")
getwd()
# List of NetCDF files
files <- list.files(pattern = "*Processed.nc")
# Check if files are found
if (length(files) == 0) {
stop("No files found in the directory with the pattern *Processed.nc")
}
# List of NetCDF files
files <- list.files("/Users/salmaabdel-raheem/Documents/GitHub/PhD/NCFileExploration",
pattern = "*Processed.nc")
# Print the files found
print(files)
# List of NetCDF files
files <- list.files("/Users/salmaabdel-raheem/Documents/GitHub/PhD/NCFileExploration",
pattern = "*Processed.nc")
# Initialize empty tibbles for Tracks and Dives with the specified column types
Tracks <- tibble(
TOPPID = double(),
SealID = character(),
Date = character(),
Lat = double(),
Lon = double(),
QCFlag = double()
)
Dives <- tibble(
TOPPID = double(),
SealID = character(),
Date = character(),
Depth = double(),
Duration = double(),
Lat = double(),
Lon = double(),
QCFlag = double()
)
# Function to read and process a NetCDF file
process_nc_file <- function(file) {
nc <- nc_open(file)
metadata <- list()
# Extract metadata
attrs <- ncatt_get(nc, 0)
for (attr in names(attrs)) {
metadata[[make.names(attr)]] <- attrs[[attr]]
}
# Extract sizes of track and dive data
Tsize <- nc_dim(nc, "TRACK")$len
Dsize <- nc_dim(nc, "TDR1")$len
# Initialize empty lists to store extracted data
track_data <- list()
dive_data <- list()
if (metadata$Data_Track_QCFlag <= 3) {
track_data <- tibble(
TOPPID = rep(metadata$Deployment_ID, Tsize),
SealID = rep(metadata$Animal_ID, Tsize),
QCFlag = rep(metadata$Data_Track_QCFlag, Tsize),
Date = ncvar_get(nc, "/TRACK/DATE"),
Lat = ncvar_get(nc, "/TRACK/LAT"),
Lon = ncvar_get(nc, "/TRACK/LON")
)
}
if (metadata$Data_TDR1_QCFlag <= 3) {
dive_data <- tibble(
TOPPID = rep(metadata$Deployment_ID, Dsize),
SealID = rep(metadata$Animal_ID, Dsize),
QCFlag = rep(metadata$Data_TDR1_QCFlag, Dsize),
Date = ncvar_get(nc, "/TDR1/DATE"),
Lat = ncvar_get(nc, "/TDR1/LAT"),
Lon = ncvar_get(nc, "/TDR1/LON"),
Depth = ncvar_get(nc, "/TDR1/MAXDEPTH"),
Duration = ncvar_get(nc, "/TDR1/DURATION")
)
}
nc_close(nc)
# Convert date strings to datetime objects
if (nrow(track_data) > 0) {
track_data <- track_data %>%
mutate(Date = ymd_hms(Date))
}
if (nrow(dive_data) > 0) {
dive_data <- dive_data %>%
mutate(Date = ymd_hms(Date))
}
list(Tracks = track_data, Dives = dive_data)
}
# Loop through each file and process it
for (file in files) {
data <- process_nc_file(file)
if (nrow(data$Tracks) > 0) {
Tracks <- bind_rows(Tracks, data$Tracks)
}
if (nrow(data$Dives) > 0) {
Dives <- bind_rows(Dives, data$Dives)
}
}
print(files)
# List of NetCDF files
files <- list.files("/Users/salmaabdel-raheem/Documents/GitHub/PhD/NCFileExploration",
pattern = "*Processed.nc")
# Initialize empty tibbles for Tracks and Dives with the specified column types
Tracks <- tibble(
TOPPID = double(),
SealID = character(),
Date = character(),
Lat = double(),
Lon = double(),
QCFlag = double()
)
Dives <- tibble(
TOPPID = double(),
SealID = character(),
Date = character(),
Depth = double(),
Duration = double(),
Lat = double(),
Lon = double(),
QCFlag = double()
)
# Function to read and process a NetCDF file
process_nc_file <- function(file) {
nc <- nc_open(file)
metadata <- list()
# Extract metadata
attrs <- ncatt_get(nc, 0)
for (attr in names(attrs)) {
metadata[[make.names(attr)]] <- attrs[[attr]]
}
# Extract sizes of track and dive data
Tsize <- nc_dim(nc, "TRACK")$len
Dsize <- nc_dim(nc, "TDR1")$len
# Initialize empty lists to store extracted data
track_data <- list()
dive_data <- list()
if (metadata$Data_Track_QCFlag <= 3) {
track_data <- tibble(
TOPPID = rep(metadata$Deployment_ID, Tsize),
SealID = rep(metadata$Animal_ID, Tsize),
QCFlag = rep(metadata$Data_Track_QCFlag, Tsize),
Date = ncvar_get(nc, "/TRACK/DATE"),
Lat = ncvar_get(nc, "/TRACK/LAT"),
Lon = ncvar_get(nc, "/TRACK/LON")
)
}
if (metadata$Data_TDR1_QCFlag <= 3) {
dive_data <- tibble(
TOPPID = rep(metadata$Deployment_ID, Dsize),
SealID = rep(metadata$Animal_ID, Dsize),
QCFlag = rep(metadata$Data_TDR1_QCFlag, Dsize),
Date = ncvar_get(nc, "/TDR1/DATE"),
Lat = ncvar_get(nc, "/TDR1/LAT"),
Lon = ncvar_get(nc, "/TDR1/LON"),
Depth = ncvar_get(nc, "/TDR1/MAXDEPTH"),
Duration = ncvar_get(nc, "/TDR1/DURATION")
)
}
nc_close(nc)
# Convert date strings to datetime objects
if (nrow(track_data) > 0) {
track_data <- track_data %>%
mutate(Date = ymd_hms(Date))
}
if (nrow(dive_data) > 0) {
dive_data <- dive_data %>%
mutate(Date = ymd_hms(Date))
}
list(Tracks = track_data, Dives = dive_data)
}
# Loop through each file and process it
for (file in files) {
data <- process_nc_file(file)
if (nrow(data$Tracks) > 0) {
Tracks <- bind_rows(Tracks, data$Tracks)
}
if (nrow(data$Dives) > 0) {
Dives <- bind_rows(Dives, data$Dives)
}
}
